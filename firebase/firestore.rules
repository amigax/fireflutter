rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }
    match /chat {
      match /rooms/{my}/{other} {
        allow read: if true;
        allow write: if my == request.auth.uid || other == request.auth.uid;
      }
      match /messages/{roomId}/{messageId} {
    	  allow read: if myChatRoom(roomId);
        allow create, update: if myChatRoom(roomId) &&
          messageParticipants(roomId) &&
          (isBlocked() == false) &&
          messageFields();
        allow delete: if myChatRoom(roomId) && myChatMessage();
      }
      match /blocks/{myId}/{otherId} {
        allow read: if ( request.auth.uid == myId || request.auth.uid == otherId);
        allow write: if ( request.auth.uid == myId );
      }
    }
    match /users/{uid} {
      allow read: if true;
      allow write: if (request.auth.uid == uid);
    }

    match /settings/{docId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    match /categories/{categoryId} {
      allow read: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    match /posts/{postId} {
      allow read: if true;
      allow create: if required(['category', 'authorUid', 'timestamp']) &&
        categoryExists() &&
        willBeMyPost()
      ;
      allow update:
        if
          // Update my document
          isMyPost() &&
          // Don't change authorUid
          willBeMyPost() &&
          required(['timestamp'])
        ;
      allow delete: if isAdmin() || isMyPost();
    }

    match /reports/{reportId} {
      allow read: if (resource.data.reporterUid == request.auth.uid);
      allow create: if (request.resource.data.reporterUid == request.auth.uid ) &&
        fieldCheck(['target', 'targetId', 'reporterUid', 'reporteeUid', 'timestamp'], ['reason']) &&
        !exists(/databases/$(database)/documents/reports/$(reportId))
      ;
      allow update: if false;
      allow delete: if false;
    }

    // check if 'A' & 'B' are blocked. 
    function isBlocked() {
      return
        exists(/databases/$(database)/documents/chat/blocks/$(request.resource.data.to)/$(request.resource.data.from)) ||
        exists(/databases/$(database)/documents/chat/blocks/$(request.resource.data.from)/$(request.resource.data.to));
    }

    // check if 'to', 'from' fiends are part of room id.
    function messageParticipants(roomId) {
      return request.resource.data.to in roomId.split('-') && request.resource.data.from in roomId.split('-');
    }

    function isAdmin() {
      return get(/databases/$(database)/documents/settings/admins).data[request.auth.uid] == true;
    }
    

    function categoryExists() {
      // let d = debug('***** category Exists ****');
      return debug(exists(/databases/$(database)/documents/categories/$(request.resource.data.category)));
    }
  }
}

// Check if roomId contains my Uid.
function myChatRoom(roomId) {
  return request.auth.uid in roomId.split('-');
}

function myChatMessage() {
  return request.auth.uid == resource.data.from;
}

function messageFields() {
  let required = ["to", "from", "timestamp", "text"];
  let optional = ["protocol"];
  return fieldCheck(required, optional);
}

// example: fieldCheck(['required', 'fields'], ['optional', 'fields'])
function fieldCheck(required, optional) {
  let all = required.concat( optional );
  // let fC = debug('****** fieldCheck *****');
  return request.resource.data.keys().hasAll( required ) && request.resource.data.keys().hasOnly(all);
}
function required(fields) {
  return request.resource.data.keys().hasAll( fields );
}


// Check if login user is the one who created the post
function isMyPost() {
  return resource.data.authorUid == request.auth.uid;
}

// Check if the post belongs to the user (after create or update).
// Use this to validate that the author does not change after updating.
function willBeMyPost() {
  return request.resource.data.authorUid == request.auth.uid;
}
