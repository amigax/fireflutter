rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }
    match /chat {
      match /rooms/{my}/{other} {
        allow read: if true;
        allow write: if my == request.auth.uid || other == request.auth.uid;
      }
      match /messages/{roomId}/{messageId} {
    	  allow read: if myChatRoom(roomId);
        allow write: if myChatRoom(roomId) &&
          messageParticipants(roomId) &&
          (isBlocked() == false) &&
          messageFields();
      }
      match /blocks/{myId}/{otherId} {
        allow read: if ( request.auth.uid == myId || request.auth.uid == otherId);
        allow write: if ( request.auth.uid == myId );
      }
    }
    match /users/{uid} {
      allow read: if true;
      allow write: if (request.auth.uid == uid);
    }
    // check if 'A' & 'B' are blocked. 
    function isBlocked() {
      return
        exists(/databases/$(database)/documents/chat/blocks/$(request.resource.data.to)/$(request.resource.data.from)) ||
        exists(/databases/$(database)/documents/chat/blocks/$(request.resource.data.from)/$(request.resource.data.to));
    }

    // check if 'to', 'from' fiends are part of room id.
    function messageParticipants(roomId) {
      return request.resource.data.to in roomId.split('-') && request.resource.data.from in roomId.split('-');
    }
  }
}
function myChatRoom(roomId) {
  return request.auth.uid in roomId.split('-');
}
function messageFields() {
  let required = ["to", "from", "timestamp", "text"];
  let optional = ["protocol"];
  return fieldCheck(required, optional);
}

function fieldCheck(required, optional) {
  let all = required.concat( optional );
  let unused = debug("** fieldCheck request.resource.data.keys() **");
  return debug(request.resource.data.keys()).hasAll( required ) && request.resource.data.keys().hasOnly(all);
}
